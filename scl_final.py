# -*- coding: utf-8 -*-
"""SCL Final by 21PT17

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IraEtf4nmAn7knp4UEhsK_yYoKKyXYlM

Newton Forward and backward
"""

# newton forward =============================================


import numpy as np
import matplotlib.pyplot as plt
from sympy import *
import math

n = int(input("Enter number of data points: "))
x=[]
y=[]

for i in range(n):
  x_v,y_v = map(float,input(f"Enter x value and y value of point {i+1}: ").split(" "))
  x.append(x_v)
  y.append(y_v)

x=np.array(x)
y=np.array(y)
x_interp1 = float(input("Enter the first value of x for interpolation: "))
x_interp2 = float(input("Enter the second value of x for interpolation: "))

x_interp3 = float(input("Enter the value of x for first and second derivative: "))
x_interp4 = float(input("Enter the another value of x for first and second derivative:"))

X=symbols('X')
xlist=[]
temp=1
for i in range(n):
  temp*=(X-x[i])
  xlist.append(temp)
xlist.insert(0,1)


table=np.zeros((n,n+1))
table[:,0]=x
table[:,1]=y



for i in range(2,n+1):
  for j in range(0,n-i+1):
    table[j][i]=table[j+1][i-1]-table[j][i-1]
for i in table:
  print(i)
h = x[1] - x[0]
poly = 0
p = (X - x[0]) / h

temp = 1
plist = []
for i in range(n):
    temp *= (p - i)
    plist.append(temp)
plist.insert(0, 1)

# Compute the polynomial
for i in range(n):
    poly += table[0][i + 1] * plist[i] / math.factorial(i)

# First derivative of the polynomial
poly_prime = poly.diff(X)

# Second derivative of the polynomial
poly_double_prime = poly_prime.diff(X)

# Evaluate the polynomial and its derivatives at x_interp1 and x_interp2
poly_interp1 = poly.subs(X, x_interp1)
poly_interp2 = poly.subs(X, x_interp2)
prime_interp1 = poly_prime.subs(X, x_interp3)
prime_interp2 = poly_prime.subs(X, x_interp4)
double_prime_interp1 = poly_double_prime.subs(X, x_interp3)
double_prime_interp2 = poly_double_prime.subs(X, x_interp4)

print("polynomial",poly)
print("first derivation of polynomial",poly_prime)
print("second derivation of polynomial",poly_double_prime)
# Print the results
print("Polynomial Interpolation at x1:", poly_interp1)
print("Polynomial Interpolation at x2:", poly_interp2)
print("First Derivative at x3:", prime_interp1)
print("First Derivative at x4:", prime_interp2)
print("Second Derivative at x3:", double_prime_interp1)
print("Second Derivative at x4:", double_prime_interp2)

# Plot the polynomial and its derivatives
x_values = np.linspace(min(x), max(x), 100)
y_values = [poly.subs(X, val) for val in x_values]
y_prime_values = [poly_prime.subs(X, val) for val in x_values]
y_double_prime_values = [poly_double_prime.subs(X, val) for val in x_values]

plt.figure()
plt.plot(x_values, y_values, label="Polynomial")
plt.plot(x_values, y_prime_values, label="First Derivative")
plt.plot(x_values, y_double_prime_values, label="Second Derivative")
plt.legend(loc="lower right")
plt.xlabel("x")
plt.ylabel("y")
plt.title("Polynomial and Its Derivatives")
plt.show()




#backward ==================================================================


#backward
import numpy as np
import matplotlib.pyplot as plt
from sympy import *
import math

n = int(input("Enter number of data points: "))
x=[]
y=[]

for i in range(n):
  x_v,y_v = map(float,input(f"Enter x value and y value of point {i+1}: ").split(" "))
  x.append(x_v)
  y.append(y_v)

x=np.array(x)
y=np.array(y)
x_interp1 = float(input("Enter the first value of x for interpolation: "))
x_interp2 = float(input("Enter the second value of x for interpolation: "))

x_interp3 = float(input("Enter the value of x for first and second derivative: "))
x_interp4 = float(input("Enter the another value of x for first and second derivative:"))

X=symbols('X')
xlist=[]
temp=1
for i in range(n):
  temp*=(X-x[i])
  xlist.append(temp)
xlist.insert(0,1)


table=np.zeros((n,n+1))
table[:,0]=x
table[:,1]=y



for i in range(2,n+1):
  for j in range(0,n-i+1):
    table[j][i]=table[j+1][i-1]-table[j][i-1]
for i in table:
  print(i)

h = x[1] - x[0]
poly = 0
p = (X - x[n - 1]) / h  # Using the last value for backward interpolation

temp = 1
plist = []
for i in range(n):
    temp *= (p + i)
    plist.append(temp)
plist.insert(0, 1)

# Compute the polynomial for backward interpolation
for i in range(1,n):
    poly += table[n - i][i] * plist[i] / math.factorial(i)
poly+=table[n-1][1]
# First derivative of the polynomial
poly_prime = poly.diff(X)

# Second derivative of the polynomial
poly_double_prime = poly_prime.diff(X)

# Evaluate the polynomial and its derivatives at x_interp1 and x_interp2
poly_interp1 = poly.subs(X, x_interp1)
poly_interp2 = poly.subs(X, x_interp2)
prime_interp1 = poly_prime.subs(X, x_interp1)
prime_interp2 = poly_prime.subs(X, x_interp2)
double_prime_interp1 = poly_double_prime.subs(X, x_interp1)
double_prime_interp2 = poly_double_prime.subs(X, x_interp2)


print("polynomial",poly)
print("first derivation of polynomial",poly_prime)
print("second derivation of polynomial",poly_double_prime)

# Print the results
print("Polynomial Interpolation at x1:", poly_interp1)
print("Polynomial Interpolation at x2:", poly_interp2)
print("First Derivative at x1:", prime_interp1)
print("First Derivative at x2:", prime_interp2)
print("Second Derivative at x1:", double_prime_interp1)
print("Second Derivative at x2:", double_prime_interp2)

# Plot the polynomial and its derivatives
x_values = np.linspace(min(x), max(x), 100)
y_values = [poly.subs(X, val) for val in x_values]
y_prime_values = [poly_prime.subs(X, val) for val in x_values]
y_double_prime_values = [poly_double_prime.subs(X, val) for val in x_values]

plt.figure()
plt.plot(x_values, y_values, label="Polynomial")
plt.plot(x_values, y_prime_values, label="First Derivative")
plt.plot(x_values, y_double_prime_values, label="Second Derivative")
plt.legend()
plt.xlabel("x")
plt.ylabel("y")
plt.title("Polynomial and Its Derivatives (Backward Interpolation)")
plt.show()

"""**Integral** using

Trapezoidal rule

simpsonâ€™s 1/3

simpson's 3/8 rule.


Simpson's 1/3 rule and Simpson's 3/8 rule may not always give the same answer when used to approximate integrals. These two methods have different formulas and are suitable for different types of functions and data. Simpson's 1/3 rule is used when you have an even number of data points, and it requires data at equidistant intervals. Simpson's 3/8 rule, on the other hand, is used when you have a multiple of 3 data points and doesn't require equidistant intervals.
"""

import numpy as np

# Define the function to be integrated
def f(x):
    return np.log(x)

# Define the limits of integration
a = 4
b = 5.2

# Number of subintervals
n = 1000

# Trapezoidal Rule
def trapezoidal_rule(f, a, b, n):
    h = (b - a) / n
    integral = (f(a) + f(b)) / 2
    for i in range(1, n):
        integral += f(a + i * h)
    integral *= h
    return integral

# Simpson's 1/3 Rule
def simpsons_one_third_rule(f, a, b, n):
    h = (b - a) / n
    x = a
    integral = f(a) + f(b)

    for i in range(1, n):
        x += h
        if i % 2 == 0:
            integral += 2 * f(x)
        else:
            integral += 4 * f(x)

    integral *= h / 3
    return integral

# Simpson's 3/8 Rule
def simpsons_three_eighth_rule(f, a, b, n):
    h = (b - a) / n
    x = a
    integral = f(a) + f(b)

    for i in range(1, n):
        x += h
        if i % 3 == 0:
            integral += 2 * f(x)
        else:
            integral += 3 * f(x)

    integral *= 3 * h / 8
    return integral

# Calculate the integrals
trapezoidal_integral = trapezoidal_rule(f, a, b, n)
simpsons_one_third_integral = simpsons_one_third_rule(f, a, b, n)
simpsons_three_eighth_integral = simpsons_three_eighth_rule(f, a, b, n)

# Print the results
print("Trapezoidal Rule Integral:", trapezoidal_integral)
print("Simpson's 1/3 Rule Integral:", simpsons_one_third_integral)
print("Simpson's 3/8 Rule Integral:", simpsons_three_eighth_integral)

# Define the function V(t) based on the given data
def V(t):
    # You can use interpolation or other methods to define V(t) based on the provided data
    # For simplicity, we will use a linear interpolation here
    t_values = [0, 5, 10, 15, 20, 25, 30, 35, 40]
    V_values = [30, 24, 19.5, 16, 13.6, 11.7, 10.0, 8.5, 7.0]

    for i in range(len(t_values) - 1):
        if t >= t_values[i] and t <= t_values[i + 1]:
            delta_t = t_values[i + 1] - t_values[i]
            delta_V = V_values[i + 1] - V_values[i]
            return V_values[i] + (delta_V / delta_t) * (t - t_values[i])

# Define numerical integration methods
def trapezoidal_rule(func, a, b, n):
    h = (b - a) / n
    result = 0.5 * (func(a) + func(b))
    for i in range(1, n):
        result += func(a + i * h)
    result *= h
    return result

def simpsons_one_third_rule(func, a, b, n):
    h = (b - a) / n
    x = [a + i * h for i in range(n + 1)]
    result = func(a) + func(b)
    for i in range(1, n):
        if i % 2 == 0:
            result += 2 * func(x[i])
        else:
            result += 4 * func(x[i])
    result *= h / 3
    return result

def simpsons_three_eighth_rule(func, a, b, n):
    h = (b - a) / n
    x = [a + i * h for i in range(n + 1)]
    result = func(a) + func(b)
    for i in range(1, n):
        if i % 3 == 0:
            result += 2 * func(x[i])
        else:
            result += 3 * func(x[i])
    result *= 3 * h / 8
    return result

# Integration interval
a = 0
b = 40

# Number of subintervals
n = 8

# Calculate distance using various integration methods
trapezoidal_distance = trapezoidal_rule(V, a, b, n)
simpsons_one_third_distance = simpsons_one_third_rule(V, a, b, n)
simpsons_three_eighth_distance = simpsons_three_eighth_rule(V, a, b, n)

# Print the results
print("Distance using Trapezoidal Rule:", trapezoidal_distance, "meters")
print("Distance using Simpson's 1/3 Rule:", simpsons_one_third_distance, "meters")
print("Distance using Simpson's 3/8 Rule:", simpsons_three_eighth_distance, "meters")

"""-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

**SOLVING FIRST ORDER ODE**

* Euler's Method

* Modified Euler

* Range Kutta method (3rd and 4th)
"""

#EULER'S METHOD

import numpy as np

# Define the differential equation
def f(x, y):
    return x - y + np.cos(x + y)

# Initial conditions
x0 = 0.1
y0 = 1.0

# Final value of x where you want to find y
x_target = 1.7

# Step size (you can adjust this for desired accuracy)
h = 0.1

# Perform Euler's method
x = x0
y = y0

while x < x_target:
    y += h * f(x, y)
    x += h

# Print the result
print("Approximate solution at x =", x_target, "is y =", y)

# Euler's method to solve a first-order differential equation

# Define the differential equation
def f(x, y):
    return (x**2 - y**2) / (x**2 + y**2)

# Initial conditions
x0 = 1  # Initial value of x
y0 = -2  # Initial value of y
x_target = 4  # The value of x where we want to find y

# Step size
h = 0.1  # You can adjust the step size as needed

# Perform Euler's method
x = x0
y = y0
while x < x_target:
    y += h * f(x, y)
    x += h

# Print the result
print(f'y({x_target}) = {y}')

# Euler's method to solve a first-order differential equation

import math

# Define the differential equation
def f(x, y):
    return math.exp(x + y) * math.sin(x * y)

# Initial conditions
x0 = 0.5  # Initial value of x
y0 = 3  # Initial value of y
x_target = 3.8  # The value of x where we want to find y

# Step size
h = 0.1  # You can adjust the step size as needed

# Perform Euler's method
x = x0
y = y0
while x < x_target:
    y += h * f(x, y)
    x += h

# Print the result
print(f'y({x_target}) = {y}')

#MODIFIED EULERS'S METHOD.

import numpy as np


# Define the differential equation
def f(x, y):
    return x**2 - y + 2*x + 4*y

# Initial condition
x0 = 0.3
y0 = -0.18

# Target value of x
x_target = 2.5

# Step size (you can adjust this for desired accuracy)
h = 0.1

# Apply Modified Euler's method
while x0 < x_target:
    k1 = h * f(x0, y0)
    k2 = h * f(x0 + h, y0 + k1)

    y0 = y0 + 0.5 * (k1 + k2)
    x0 += h

# Print the result
print("Approximate solution at x =", x_target, "is y =", y0)

# Modified Euler's method to solve a first-order differential equation

# Define the differential equation
def f(x, y):
    return (x + y**2 - 2*x*y) / (x**2 - y**2 + 2*x)

# Initial conditions
x0 = -1  # Initial value of x
y0 = 0  # Initial value of y
x_target = 2  # The value of x where we want to find y

# Step size
h = 0.1  # You can adjust the step size as needed

# Perform Modified Euler's method
x = x0
y = y0
while x < x_target:
    k1 = h * f(x, y)
    k2 = h * f(x + h, y + k1)
    y += 0.5 * (k1 + k2)
    x += h

# Print the result
print(f'y({x_target}) = {y}')

# Modified Euler's method to solve a first-order differential equation

import math

# Define the differential equation
def f(x, y):
    return math.cos(x + y) * math.sin(x * y)**2

# Initial conditions
x0 = math.pi  # Initial value of x
y0 = -math.pi  # Initial value of y
x_target = 3 * math.pi  # The value of x where we want to find y

# Step size
h = 0.1  # You can adjust the step size as needed

# Perform Modified Euler's method
x = x0
y = y0
while x < x_target:
    k1 = h * f(x, y)
    k2 = h * f(x + h, y + k1)
    y += 0.5 * (k1 + k2)
    x += h

# Print the result
print(f'y({x_target}) = {y}')

#RANGE KUTTA METHOD (3rd ORDER)
#1)

import numpy as np

# Define the differential equation
def f(x, y):
    return x * y / (x**2 + y**2 - x * y)

# Initial conditions
x0 = 0.0
y0 = 10.0

# Final value of x where you want to find y
x_target = 3.0

# Step size (you can adjust this for desired accuracy)
h = 0.1

# Perform third-order Runge-Kutta method
x = x0
y = y0

while x < x_target:
    k1 = h * f(x, y)
    k2 = h * f(x + h / 2, y + k1 / 2)
    k3 = h * f(x + h, y - k1 + 2 * k2)

    y += (k1 + 4 * k2 + k3) / 6
    x += h

# Print the result
print("Approximate solution at x =", x_target, "is y =", y)

# Runge-Kutta method of third order to solve a first-order differential equation
#2)


import math

# Define the differential equation
def f(x, y):
    return math.tan(x) / math.exp(x + y)

# Initial conditions
x0 = -0.5  # Initial value of x
y0 = -1.5  # Initial value of y
x_target = 0.75  # The value of x where we want to find y

# Step size
h = 0.1  # You can adjust the step size as needed

# Perform Runge-Kutta method of third order
x = x0
y = y0
while x < x_target:
    k1 = h * f(x, y)
    k2 = h * f(x + h/2, y + k1/2)
    k3 = h * f(x + h, y - k1 + 2*k2)
    y += (k1 + 4*k2 + k3) / 6
    x += h

# Print the result
print(f'y({x_target}) = {y}')

# Runge-Kutta method of third order to solve a first-order differential equation
#3)


import math

# Define the differential equation
def f(x, y):
    return math.cos(x + y) * (x**2 + 2*y)

# Initial conditions
x0 = -2  # Initial value of x
y0 = -1  # Initial value of y
x_target = 1  # The value of x where we want to find y

# Step size
h = 0.1  # You can adjust the step size as needed

# Perform Runge-Kutta method of third order
x = x0
y = y0
while x < x_target:
    k1 = h * f(x, y)
    k2 = h * f(x + h/2, y + k1/2)
    k3 = h * f(x + h, y - k1 + 2*k2)
    y += (k1 + 4*k2 + k3) / 6
    x += h

# Print the result
print(f'y({x_target}) = {y}')

#RANGE KUTTA METHOD (4th ORDER)
#1)


import numpy as np

# Define the differential equation
def f(x, y):
    return x * y + x - y**3

# Initial conditions
x0 = 1.0
y0 = -4.0

# Final value of x where you want to find y
x_target = 2.5

# Step size (you can adjust this for desired accuracy)
h = 0.1

# Perform fourth-order Runge-Kutta method
x = x0
y = y0

while x < x_target:
    k1 = h * f(x, y)
    k2 = h * f(x + h/2, y + k1/2)
    k3 = h * f(x + h/2, y + k2/2)
    k4 = h * f(x + h, y + k3)

    y += (k1 + 2 * k2 + 2 * k3 + k4) / 6
    x += h

# Print the result
print("Approximate solution at x =", x_target, "is y =", y)

"""**Milne's Predictor-Corrector method is a fourth-order explicit method for solving ordinary differential equations. The Adam-Bashforth method is also an explicit method for solving differential equations.**"""

# 1. Milneâ€™s predictor corrector method and Adam Bashforth method

'''
Given 2dy/dx = (1 + x^2)y^2 and y(0) = 1, y(0.1) = 1.06,
y(0.2) = 1.12, y(0.3) = 1.21, evaluate y(0.4) by Milneâ€™s
predictor corrector method and Adam Bashforth method.
'''


import numpy as np
import math

def f(x,y):
    return ((1 + x**2)*y**2)/2

h = 0.1

x0 = 0
y0 = 1

x1 = 0.1
y1 = 1.06

x2 = x0 + h
y2 = 1.12

x3 = x1 + h
y3 = 1.21

x4 = x2 + h

#Adams Predictor formula
yp4 = y3 + h*(55*f(x3,y3) - 59*f(x2,y2) + 37*f(x1,y1) - 9*f(x0,y0))/24
x4 = x3 + h
fp4 = f(x4,yp4)
print('Adams Predictor formula')
print( 'y predicted Value = ',yp4 )
print ('f(y predicted)  = ',fp4)

#Adams Corrector formula
yc4 = y3 + h*( f(x1,y1) - 5*f(x2,y2) + 19*f(x3,y3) + 9*fp4 )/24
f4 = f(x4,yc4)
print( '\nAdams Corrector formula')
print( 'y Corrected Value = ',yc4)
print( 'f(y Corrected) = ',f4 )

yc4 = y3 + h*( f(x1,y1) - 5*f(x2,y2) + 19*f(x3,y3) + 9*f4 )/24
print ('\nRefined y = ',yc4)

print("-----------------------------")



#Milne Predictor formula
yp4 = y0 + 4*h*(2*f(x1,y1) - f(x2,y2) + 2*f(x3,y3))/3
x4 = x3 + h
fp4 = f(x4,yp4)
print("Milneâ€™s predictor corrector method")
print( 'y predicted Value = ',yp4 )
print ('f(y predicted)  = ',fp4)

#Simpson Corrector formula
yc4 = y2 + h*( f(x2,y2) + 4*f(x3,y3) + fp4)/3
f4 = f(x4,yc4)
print( 'y Corrected Value = ',yc4)
print( 'f(y Corrected) = ',f4 )


yc4 = y2 + h*( f(x2,y2) + 4*f(x3,y3) + f4)/3
print ('\n Refined y = ',yc4)

print("-----------------------------")

#2. milne using runge kutta third order

'''
Using Runge-Kutta third method, solve dy/dx = xy + x^2, y(0) = 1;
at x = 0.1, 0.2, 0.3. Continue the solution at x = 0.4 by Milneâ€™s
predictor corrector method and Adam Bashforth method.
'''

def runge_kutta_third_order(f, x0, y0, h, num_steps):
    x = x0
    y = y0

    for _ in range(num_steps):
        k1 = h * f(x, y)
        k2 = h * f(x + h / 2, y + k1 / 2)
        k3 = h * f(x + h, y - k1 + 2 * k2)

        y = y + (k1 + 4 * k2 + k3) / 6
        x = x + h

    return x, y

def f(x, y):
    return x*y + x**2

x0 = 0
y0 = 1
h = 0.1

xVals = [0.1, 0.2, 0.3]
yVals = []
for i in xVals:
    num_steps = int((i - x0) / h)
    xf, yf = runge_kutta_third_order(f, x0, y0, h, num_steps)
    yVals.append(yf)


x1, x2, x3 = 0.1, 0.2, 0.3
y1, y2, y3 = yVals[0], yVals[1], yVals[2]

x4 = x2 + h

#Adams Predictor formula
yp4 = y3 + h*(55*f(x3,y3) - 59*f(x2,y2) + 37*f(x1,y1) - 9*f(x0,y0))/24
x4 = x3 + h
fp4 = f(x4,yp4)
print('Adams Predictor formula')
print( 'y predicted Value = ',yp4 )
print ('f(y predicted)  = ',fp4)
#Adams Corrector formula
yc4 = y3 + h*( f(x1,y1) - 5*f(x2,y2) + 19*f(x3,y3) + 9*fp4 )/24
f4 = f(x4,yc4)
print( '\nAdams Corrector formula')
print( 'y Corrected Value = ',yc4)
print( 'f(y Corrected) = ',f4 )

yc4 = y3 + h*( f(x1,y1) - 5*f(x2,y2) + 19*f(x3,y3) + 9*f4 )/24
print ('\nRefined y = ',yc4)

print("-----------------------------")
#Milne Predictor formula
yp4 = y0 + 4*h*(2*f(x1,y1) - f(x2,y2) + 2*f(x3,y3))/3
x4 = x3 + h
fp4 = f(x4,yp4)
print("Milneâ€™s predictor corrector method")
print( 'y predicted Value = ',yp4 )
print ('f(y predicted)  = ',fp4)
#Simpson Corrector formula
yc4 = y2 + h*( f(x2,y2) + 4*f(x3,y3) + fp4)/3
f4 = f(x4,yc4)
print( 'y Corrected Value = ',yc4)
print( 'f(y Corrected) = ',f4 )


yc4 = y2 + h*( f(x2,y2) + 4*f(x3,y3) + f4)/3
print ('\n Refined y = ',yc4)

print("-----------------------------")

# 3.milne using kutta fourth order

'''
Using Runge-Kutta fourth order method, calculate y(0.1), y(0.2)
and y(0.3) given that dy/dx = 2xy / 1 + x^2
, y(0) = 0; . Continue the solution
at x = 0.4 by Milneâ€™s predictor corrector method and Adam Bashforth method.
'''

def runge_kutta_fourth_order(f, x0, y0, h, num_steps):
    x = x0
    y = y0

    for _ in range(num_steps):
        k1 = h * f(x, y)
        k2 = h * f(x + h/2, y + k1/2)
        k3 = h * f(x + h/2, y + k2/2)
        k4 = h * f(x + h, y + k3)

        y = y + (k1 + 2*k2 + 2*k3 + k4) / 6
        x = x + h

    return x, y

def f(x, y):
    return x*y + x**2

x0 = 0
y0 = 1
h = 0.1

xVals = [0.1, 0.2, 0.3]
yVals = []
for i in xVals:
    num_steps = int((i - x0) / h)
    xf, yf = runge_kutta_fourth_order(f, x0, y0, h, num_steps)
    yVals.append(yf)


x1, x2, x3 = 0.1, 0.2, 0.3
y1, y2, y3 = yVals[0], yVals[1], yVals[2]

x4 = x2 + h

#Adams Predictor formula
yp4 = y3 + h*(55*f(x3,y3) - 59*f(x2,y2) + 37*f(x1,y1) - 9*f(x0,y0))/24
x4 = x3 + h
fp4 = f(x4,yp4)
print('Adams Predictor formula')
print( 'y predicted Value = ',yp4 )
print ('f(y predicted)  = ',fp4)
#Adams Corrector formula
yc4 = y3 + h*( f(x1,y1) - 5*f(x2,y2) + 19*f(x3,y3) + 9*fp4 )/24
f4 = f(x4,yc4)
print( '\nAdams Corrector formula')
print( 'y Corrected Value = ',yc4)
print( 'f(y Corrected) = ',f4 )

yc4 = y3 + h*( f(x1,y1) - 5*f(x2,y2) + 19*f(x3,y3) + 9*f4 )/24
print ('\nRefined y = ',yc4)

print("-----------------------------")
#Milne Predictor formula
yp4 = y0 + 4*h*(2*f(x1,y1) - f(x2,y2) + 2*f(x3,y3))/3
x4 = x3 + h
fp4 = f(x4,yp4)
print("Milneâ€™s predictor corrector method")
print( 'y predicted Value = ',yp4 )
print ('f(y predicted)  = ',fp4)
#Simpson Corrector formula
yc4 = y2 + h*( f(x2,y2) + 4*f(x3,y3) + fp4)/3
f4 = f(x4,yc4)
print( 'y Corrected Value = ',yc4)
print( 'f(y Corrected) = ',f4 )


yc4 = y2 + h*( f(x2,y2) + 4*f(x3,y3) + f4)/3
print ('\n Refined y = ',yc4)

print("-----------------------------")

#4. euler milne

'''
Using Eulerâ€™s method, calculate y(0.1), y(0.2) and y(0.3) given
that dy/dx = 2xy / 1+x^2 , y(0) = 0; . Continue the solution at x = 0.4 by
Milneâ€™s predictor corrector method and Adam Bashforth method.
'''


def f(x, y):
    return (2 - y**2) / (5 * x)

def euler(x0, y, h, x):
    temp = 0
    while x0 < x:
        temp = y
        y = y + h * f(x0, y)
        x0 = x0 + h
    return y0


def milne_predictor_corrector(x0, y0, h, xn):
    y1 = euler(x0, y0, h, x0 + h)
    y2 = euler(x0, y0, h, x0 + 2*h)
    y3 = euler(x0, y0, h, x0 + 3*h)
    while x0 < xn:
        y4_predict = y0 + (4*h/3) * (2*f(x0, y0) - f(x0 + h, y1) + 2*f(x0 + 2*h, y2))
        y4_correct = y2 + (h/3) * (f(x0 + 2*h, y2) + 4*f(x0 + h, y1) + f(x0, y0))
        y0, y1, y2, y3 = y1, y2, y3, y4_correct
        x0 = x0 + h
    return y4_correct

def adam_bashforth(x0, y0, h, xn):
    y1 = euler(x0, y0, h, x0 + h)
    y2 = euler(x0, y0, h, x0 + 2*h)
    y3 = euler(x0, y0, h, x0 + 3*h)
    while x0 < xn:
        y4_predict = y3 + (h/24) * (55*f(x0 + 3*h, y3) - 59*f(x0 + 2*h, y2) + 37*f(x0 + h, y1) - 9*f(x0, y0))
        y4_correct = y3 + (h/24) * (9*f(x0 + h, y4_predict) + 19*f(x0 + 3*h, y3) - 5*f(x0 + 2*h, y2) + f(x0, y0))
        y0, y1, y2, y3 = y1, y2, y3, y4_correct
        x0 = x0 + h
    return y4_correct

y0 = 1
x0 = 4
h = 0.1
xn1 = 4.1
xn2 = 4.2
xn3 = 4.3
xn4 = 4.4

y1 = euler(x0, y0, h, xn1)
y2 = euler(x0, y0, h, xn2)
y3 = euler(x0, y0, h, xn3)
y4_milne = milne_predictor_corrector(x0, y0, h, xn4)
y4_adam = adam_bashforth(x0, y0, h, xn4)

print(f"y({xn1}) = {y1}")
print(f"y({xn2}) = {y2}")
print(f"y({xn3}) = {y3}")
print(f"y({xn4}) by Milne's predictor corrector method = {y4_milne}")
print(f"y({xn4}) by Adam Bashforth method = {y4_adam}")

#5. modified euler

'''
Using Modified Eulerâ€™s method, calculate y(4.1), y(4.2) and y(4.3)
given that 5xy' + y^2 = 2, y(4) = 1; . Continue the solution at
x = 4.4 by Milneâ€™s predictor corrector method and Adam Bashforth method.

'''

def f(x, y):
    return (2 - y**2) / (5 * x)

def modified_euler(x0, y0, h, xn):
    while x0 < xn:
        y0 = y0 + h * f(x0 + h/2, y0 + (h/2) * f(x0, y0))
        x0 = x0 + h
    return y0

def milne_predictor_corrector(x0, y0, h, xn):
    y1 = modified_euler(x0, y0, h, x0 + h)
    y2 = modified_euler(x0, y0, h, x0 + 2*h)
    y3 = modified_euler(x0, y0, h, x0 + 3*h)
    while x0 < xn:
        y4_predict = y0 + (4*h/3) * (2*f(x0, y0) - f(x0 + h, y1) + 2*f(x0 + 2*h, y2))
        y4_correct = y2 + (h/3) * (f(x0 + 2*h, y2) + 4*f(x0 + h, y1) + f(x0, y0))
        y0, y1, y2, y3 = y1, y2, y3, y4_correct
        x0 = x0 + h
    return y4_correct

def adam_bashforth(x0, y0, h, xn):
    y1 = modified_euler(x0, y0, h, x0 + h)
    y2 = modified_euler(x0, y0, h, x0 + 2*h)
    y3 = modified_euler(x0, y0, h, x0 + 3*h)
    while x0 < xn:
        y4_predict = y3 + (h/24) * (55*f(x0 + 3*h, y3) - 59*f(x0 + 2*h, y2) + 37*f(x0 + h, y1) - 9*f(x0, y0))
        y4_correct = y3 + (h/24) * (9*f(x0 + h, y4_predict) + 19*f(x0 + 3*h, y3) - 5*f(x0 + 2*h, y2) + f(x0, y0))
        y0, y1, y2, y3 = y1, y2, y3, y4_correct
        x0 = x0 + h
    return y4_correct

y0 = 1
x0 = 4
h = 0.1
xn1 = 4.1
xn2 = 4.2
xn3 = 4.3
xn4 = 4.4

y1 = modified_euler(x0, y0, h, xn1)
y2 = modified_euler(x0, y0, h, xn2)
y3 = modified_euler(x0, y0, h, xn3)
y4_milne = milne_predictor_corrector(x0, y0, h, xn4)
y4_adam = adam_bashforth(x0, y0, h, xn4)

print(f"y({xn1}) = {y1}")
print(f"y({xn2}) = {y2}")
print(f"y({xn3}) = {y3}")
print(f"y({xn4}) by Milne's predictor corrector method = {y4_milne}")
print(f"y({xn4}) by Adam Bashforth method = {y4_adam}")